Vercel `exports is not defined` エラー対策 詳細チェックリスト

**前提:**
*   `package.json` に `"type": "module"` が記述されているか、あるいはCommonJSルートを試す場合は削除/変更されているかを確認。
*   Vercelのプロジェクト設定でNode.jsのバージョン (18.x, 20.x) を意識的に選択しているか確認。

### 0. 基本設定と環境の確認

*   [ ] **`tsconfig.json` / `tsconfig.node.json` の確認**:
    *   `module` が `esnext` または `nodenext` (ESMルートの場合) / `CommonJS` (CJSルートの場合) になっているか確認。
    *   `target` が `ES2020` 以上になっているか確認（古い設定だと import/export トランスパイルが怪しくなる）。
*   [ ] **Node ランタイム切替テスト**:
    *   Vercelプロジェクト設定で Node.js `20.x` と `18.x` を両方試し、エラーに変化があるか確認（内部 fetch 実装が微妙に違う）。
*   [ ] **環境変数まわり (`.env`, Vercel UI)**:
    *   (Difyロジックを戻した場合) `DIFY_API_KEY` などの必要な環境変数がVercelのプロジェクト設定に正しく設定されているか確認。
    *   サーバーレス関数内で `console.log(process.env)` を一時的に使用し、環境変数がランタイムに渡っているか確認 (確認後は削除)。
*   [ ] **`vercel.json` / ビルダー設定**:
    *   `vercel.json` が存在する場合、内容を確認。意図しない設定が残っていないか。
        *   例: `functions` セクションで `"api/**/*.ts": { "runtime": "@vercel/node@バージョン" }` のようにランタイムやビルダーを明示しているか、あるいはそれが問題を引き起こしていないか。
    *   特に理由がなければ `vercel.json` は削除し、Vercelの規約ベースの動作を試す（ない方がシンプルに動くケース多い）。 **← 誤って残していないか確認**
*   [ ] **`.vercelignore` / `dist` 重複確認**:
    *   Gitリポジトリに `dist/` や `.vercel/output` のようなビルド済み成果物が誤って含まれていないか確認。`.gitignore` で適切に除外されているか。 (古いビルド済みJSが読み込まれる原因になる)

### 1. APIファイルのクリーンアップと統一 (ES Moduleルートの場合)

*   [ ] **対象APIファイルの特定**:
    *   エラーが発生しているAPIファイル (例: `api/dify-chat.ts`) を特定。
    *   テスト用に最小限のAPIファイル (例: `api/ping.ts` または `api/ping.mjs`) を新規作成。
*   [ ] **ファイル内容の確認 (ES Module形式への統一)**:
    *   対象APIファイルの内容が、純粋なES Module形式であることを確認。
        ```typescript
        // 例: api/ping.ts
        import type { VercelRequest, VercelResponse } from '@vercel/node';

        export default function handler(req: VercelRequest, res: VercelResponse) {
          if (req.method === 'GET') {
            res.status(200).json({ message: 'ping ok (esm)' });
          } else {
            res.setHeader('Allow', ['GET']);
            res.status(405).end(`Method ${req.method} Not Allowed`);
          }
        }
        ```
    *   `require()` を使用していないか確認。
    *   `module.exports` や `exports.` を使用していないか確認。
    *   `export default function ...` または `export const ...` 形式でエクスポート。
*   [ ] **拡張子の確認**:
    *   TypeScriptの場合は `.ts`。
    *   JavaScript (ES Module) の場合は `.mjs` (推奨) または `.js`。
    *   `.mts` (ESM TypeScript) / `.cts` (CJS TypeScript) のような拡張子を意図せず混在させていないか再チェック。
*   [ ] **関連ファイルの削除 (重要)**:
    *   同じAPI名で、異なる拡張子のファイルや古いファイルがリポジトリ内に残っていないか確認 (例: `api/dify-chat.js`, `api/dify-chat.cjs` など)。**もし存在すれば完全に削除する。**
    *   ローカルだけでなく、Gitリポジトリからも削除されていることを確認。
*   [ ] **依存関係の確認**:
    *   `@vercel/node` が `devDependencies` に含まれているか確認 (`package.json`)。

### 2. CommonJSフォールバック確認 (ESMルートで解決しない場合)

*   [ ] **`package.json` の変更**:
    *   `"type": "module"` を削除、または `"type": "commonjs"` に変更。
*   [ ] **APIファイルの変更**:
    *   対象APIファイルの拡張子を `.cjs` に変更 (例: `api/ping.cjs`)。
    *   ファイル内容を完全にCommonJS形式に統一。
        ```javascript
        // 例: api/ping.cjs
        module.exports = (req, res) => { // req, res は VercelRequest, VercelResponse (型は使えないか、JSDocで補う)
          if (req.method === 'GET') {
            res.status(200).json({ message: 'ping ok (cjs)' });
          } else {
            res.setHeader('Allow', ['GET']);
            res.status(405).end(`Method ${req.method} Not Allowed`);
          }
        };
        ```
*   [ ] **古いESM形式ファイルの削除**:
    *   同じAPI名で `.ts`, `.mjs`, `.js` (ESMのつもりだったもの) ファイルが残っていれば完全に削除。
*   [ ] **`tsconfig.node.json` の調整**:
    *   `module` を `CommonJS` に、`moduleResolution` を `Node` など、CommonJSに適した設定に変更。

### 3. Gitリポジトリの確認とプッシュ

*   [ ] **変更のステージングとコミット**:
    *   上記で行ったファイルの変更、追加、削除を全てGitでステージング (`git add .`)。
    *   変更内容を明確に示すメッセージでコミット。
*   [ ] **リモートリポジトリへのプッシュ**:
    *   コミットをGitHubなどのリモートリポジトリにプッシュ (`git push`)。

### 4. ローカルでのビルドと動作確認

*   [ ] **ローカルビルド検証**:
    *   ターミナルで `npx vercel build` を実行。
    *   ビルドが成功するか確認。
    *   `.vercel/output/functions/api/` ディレクトリ内に生成されたコード (例: `ping.js` や `dify-chat.js`) を確認し、意図したモジュール形式 (ESMかCJSか) になっているか、不要なコードが混入していないか確認。
*   [ ] **ローカル `vercel dev` での動作確認**:
    *   ターミナルで `vercel dev` を実行。
    *   ローカルサーバー (例: `http://localhost:3000/api/ping`) にアクセスし、期待通りのレスポンスが返るか確認。
    *   Vercelデプロイ環境と同じエラー (500 / `exports is not defined` など) がローカルで再現するか確認（ローカルで再現しない = Vercel側のビルダー問題を絞り込める）。

### 5. Vercelでのデプロイと確認

*   [ ] **Vercelプロジェクト設定の再確認**:
    *   Node.jsバージョンが意図したものになっているか確認。
*   [ ] **キャッシュを無効にして再デプロイ (重要)**:
    *   Vercelのダッシュボードから手動でデプロイする場合、「Redeploy」の際に「Use existing Build Cache」の **チェックを外す**。
    *   または、Vercel CLIを使用している場合は `vercel deploy --force` を実行。
*   [ ] **デプロイソースの確認**:
    *   デプロイ完了後、Vercelダッシュボードの「Source」タブで、実際にデプロイされたAPIファイルの内容が最新のものと一致しているか確認。
*   [ ] **ビルドログの確認**:
    *   デプロイ時の「Build Logs」にエラーや不審な警告が出ていないか確認。
*   [ ] **動作確認 (最小API)**:
    *   デプロイされた最小API (例: `/api/ping`) にアクセスし、期待通りのレスポンスとステータスコード200が返ってくるか確認。
*   [ ] **関数ログの確認**:
    *   もし動作しない場合、Vercelダッシュボードの「Logs」タブで、該当関数の実行ログを確認し、エラー内容を記録。
*   [ ] **タイムアウト & メモリ枠の確認 (Difyロジックの場合)**:
    *   (Difyロジックを戻した場合) `api/dify-chat` はストリーミングで実行時間が長くなる可能性あり。Logsで `maxDuration` やメモリ不足でkillされていないか確認。
*   [ ] **HTTP モード切替テスト (Difyロジックの場合)**:
    *   (Difyロジックを戻した場合) Dify APIリクエストの `response_mode: "blocking"` に一時的に切り替え、ストリーミング処理依存を除外した状態で同じエラーが発生するか検証。

### 6. Difyロジックの段階的復元 (最小APIが成功した場合)

*   [ ] 最小API (`/api/ping`) が正常に動作することを確認後、元の `api/dify-chat.ts` (または `.cjs`) にDify連携ロジックを少しずつ戻しながら、どの段階で問題が再発するかを特定する。
    *   環境変数の読み込み部分
    *   リクエストボディのパース部分
    *   Dify APIへのfetchリクエスト部分
    *   ストリーミングレスポンス処理部分

### 7. 問題が解決しない場合

*   [ ] **Vercelサポートへの問い合わせ準備**:
    *   これまでの全ての試行手順と結果（特にこのチェックリストのどの段階で、どのような設定で問題が発生したか）。
    *   GitHubリポジトリへのリンク。
    *   Vercelプロジェクト名、エラーが発生するデプロイメントID。
    *   関数ログのエラーメッセージ全文とスタックトレース。
    *   「Node.js 18.x (または20.x)環境で、(ESMルートの場合) 正しいシンプルなESモジュールコードがデプロイされているにも関わらず、CommonJSの `exports is not defined` エラーが出る」といった問題の核心を伝える。